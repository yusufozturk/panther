package mage

/**
 * Panther is a Cloud-Native SIEM for the Modern Security Team.
 * Copyright (C) 2020 Panther Labs Inc
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

import (
	"bytes"
	"encoding/json"
	"fmt"
	"html"
	"path/filepath"
	"reflect"
	"sort"
	"strings"

	"github.com/alecthomas/jsonschema"

	"github.com/panther-labs/panther/internal/log_analysis/log_processor/parsers"
	"github.com/panther-labs/panther/internal/log_analysis/log_processor/registry"
	"github.com/panther-labs/panther/tools/cfndoc"
	"github.com/panther-labs/panther/tools/cfngen/gluecf"
)

// Auto-generate specific sections of documentation
func Doc() {
	if err := doc(); err != nil {
		logger.Fatal(err)
	}
}

func doc() error {
	if err := opDocs(); err != nil {
		return err
	}
	return logDocs()
}

const (
	inventoryDocHeader = `
<!-- This document is generated by "mage doc:cfn". DO NOT EDIT! -->

# Panther Application Run Books

Refer to the 
[Cloud Security](https://docs.runpanther.io/policies/scanning#how-it-works)
and
[Log Analysis](https://docs.runpanther.io/log-analysis/log-processing#how-it-works)
architecture diagrams for context.

Resource names below refer to resources in the Cloud Formation templates in Panther.

Each resource describes its function and failure impacts.

`
)

// generate operational documentation from deployment CloudFormation
func opDocs() error {
	logger.Infof("doc: generating operational documentation from cloudformation")
	docs, err := cfndoc.ReadCfn(cfnFiles()...)
	if err != nil {
		return fmt.Errorf("failed to generate operational documentation: %v", err)
	}

	var docsBuffer bytes.Buffer
	docsBuffer.WriteString(inventoryDocHeader)
	for _, doc := range docs {
		docsBuffer.WriteString(fmt.Sprintf("## %s\n%s\n\n", doc.Resource, doc.Documentation))
	}

	return writeFile(filepath.Join("docs", "gitbook", "operations", "runbooks.md"), docsBuffer.Bytes())
}

const (
	parserReadmeHeader = `
<!-- This document is generated by "mage doc:logs". DO NOT EDIT! -->
`
)

func logDocs() error {
	logger.Infof("doc: generating documentation on supported logs")
	outDir := filepath.Join("docs", "gitbook", "log-analysis", "log-processing", "supported-logs")

	// group the data by category
	tables := registry.AvailableTables()
	logCategories := make(map[string][]string) // category -> logTypes
	for _, table := range tables {
		logType := table.LogType()
		categoryType := strings.Split(logType, ".")
		if len(categoryType) != 2 {
			return fmt.Errorf("unexpected logType format: %s", logType)
		}
		logCategories[categoryType[0]] = append(logCategories[categoryType[0]], logType)
	}
	var sortedCategories []string
	for category := range logCategories {
		sortedCategories = append(sortedCategories, category)
		sort.Strings(logCategories[category])
	}
	sort.Strings(sortedCategories)

	docCategory := func(category string) error {
		var docsBuffer bytes.Buffer
		logTypes := logCategories[category]
		docsBuffer.WriteString(parserReadmeHeader)
		docsBuffer.WriteString(fmt.Sprintf("# %s\n%sRequired fields are in <b>bold</b>.%s\n",
			category,
			`{% hint style="info" %}`,
			`{% endhint %}`))

		// use html table to get needed control
		for _, logType := range logTypes {
			table := registry.AvailableParsers().LookupParser(logType).GlueTableMetadata

			description := html.EscapeString(table.Description())

			docsBuffer.WriteString(fmt.Sprintf("##%s\n%s\n", logType, description))

			// add schema as html table since markdown won't let you embed tables
			docsBuffer.WriteString(`<table>` + "\n")
			docsBuffer.WriteString("<tr><th align=center>Column</th><th align=center>Type</th><th align=center>Description</th></tr>\n") // nolint

			columns := gluecf.InferJSONColumns(table.EventStruct(), gluecf.GlueMappings...) // get the Glue schema
			for _, column := range columns {
				colName := column.Name
				if column.Required {
					colName = "<b>" + colName + "</b>" // required elements are bold
				}
				docsBuffer.WriteString(fmt.Sprintf("<tr><td valign=top>%s</td><td>%s</td><td valign=top>%s</td></tr>\n",
					formatColumnName(colName),
					formatType(column),
					html.EscapeString(column.Comment)))
			}

			docsBuffer.WriteString("</table>\n\n")
		}

		return writeFile(filepath.Join(outDir, category+".md"), docsBuffer.Bytes())
	}

	// one file per category
	for _, category := range sortedCategories {
		if err := docCategory(category); err != nil {
			return err
		}
	}

	return nil
}

func formatColumnName(name string) string {
	return "<code>" + name + "</code>"
}

func formatType(col gluecf.Column) string {
	complexTypes := []string{"array", "struct", "map"}
	complex := false
	for _, ct := range complexTypes {
		if strings.HasPrefix(col.Type, ct) {
			complex = true
			break
		}
	}

	// if NOT a complex type we just use the Glue type
	if !complex {
		return "<code>" + col.Type + "</code>"
	}

	// complex Glue types are hard to read, so use JSON schema
	colType := col.Field.Type
	switch colType.String() { // handle special Panther types that will not work with JSON schema
	case reflect.TypeOf(&parsers.PantherAnyString{}).String():
		colType = reflect.TypeOf([]string{}) // slice of strings
	}
	// deference pointers
	if colType.Kind() == reflect.Ptr {
		colType = colType.Elem()
	}

	// we need to create a temp struct for the parser to work
	isStruct := true
	if colType.Kind() != reflect.Struct {
		isStruct = false
		fields := []reflect.StructField{
			{
				Name: col.Field.Name,
				Type: colType,
				Tag:  col.Field.Tag,
			},
		}
		colType = reflect.StructOf(fields)
	}

	// we need to wrap because schema package needs Name() and PkgPath()
	reflector := &jsonschema.Reflector{ExpandedStruct: false}
	colSchema := reflector.ReflectFromType(&docType{Type: colType, name: col.Name})

	const prefix = "<br>"
	const indent = "&nbsp;&nbsp;"
	const padLength = 32 // used to force width, since gitbook ignores style

	var htmlBuffer bytes.Buffer
	htmlBuffer.WriteString("<code>")
	firstProp := true
	// sort for consistency in output
	var names []string
	for name := range colSchema.Definitions {
		names = append(names, name)
	}
	sort.Strings(names)
	for _, name := range names {
		schemaType := colSchema.Definitions[name]
		// NOTE: we cannot use jsoniter package because it does not support prefix
		var schemaProps interface{}
		schemaProps = schemaType.Properties
		if !isStruct { // we had to make a temp struct above, dereference
			if colProps, found := schemaType.Properties.Get(col.Name); found {
				schemaProps = colProps
			}
		}

		jsonProps, err := json.MarshalIndent(schemaProps, prefix, indent)
		if err != nil {
			logger.Fatal(err)
		}

		if !firstProp {
			htmlBuffer.WriteString("<br><br>")
		}

		jsonPropsString := (string)(jsonProps)
		if jsonPropsString != "{}" { // skip empty
			if name != col.Name {
				htmlBuffer.WriteString(fmt.Sprintf(`"%s":`, name))
			}
			// remove junk that messes up formatting
			jsonPropsString = strings.Replace(jsonPropsString, `"#/definitions/`, `"`, -1)
			jsonPropsString = strings.Replace(jsonPropsString, `"$schema": "http://json-schema.org/draft-04/schema#",`, ``, -1)

			htmlBuffer.WriteString(jsonPropsString)
		} else if name == "RFC3339" { // special case for our timestamps embedded in structs
			htmlBuffer.WriteString(fmt.Sprintf(`"%s": `, name))
			htmlBuffer.WriteString("{" + prefix + indent + `"type": "timestamp"` + prefix + "}")
		}

		firstProp = false // clear
	}
	htmlBuffer.WriteString(padLine(padLength))
	htmlBuffer.WriteString("</code>")
	return htmlBuffer.String()
}

// used to force width, since gitbook ignores style
func padLine(n int) string {
	var padBuffer bytes.Buffer
	for i := 0; i < n; i++ {
		padBuffer.WriteString("&nbsp;")
	}
	return padBuffer.String()
}

type docType struct {
	reflect.Type
	name string
}

func (dt *docType) Name() string {
	return dt.name
}

func (dt *docType) PkgPath() string {
	return "nopath" // this can be any non-empty value for the json parser to work
}
